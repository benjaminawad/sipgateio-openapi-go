/*
sipgate API

This is the sipgate REST API documentation. We build our applications on this API and we invite you to use it too.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HistoryApiService HistoryApi service
type HistoryApiService service

type ApiDeleteHistoryEntriesRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	id *[]string
}

// List of entry ids to delete
func (r ApiDeleteHistoryEntriesRequest) Id(id []string) ApiDeleteHistoryEntriesRequest {
	r.id = &id
	return r
}

func (r ApiDeleteHistoryEntriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHistoryEntriesExecute(r)
}

/*
DeleteHistoryEntries Delete multiple calls, faxes, SMS or voicemails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteHistoryEntriesRequest
*/
func (a *HistoryApiService) DeleteHistoryEntries(ctx context.Context) ApiDeleteHistoryEntriesRequest {
	return ApiDeleteHistoryEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *HistoryApiService) DeleteHistoryEntriesExecute(r ApiDeleteHistoryEntriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.DeleteHistoryEntries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteHistoryEntryRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
}

func (r ApiDeleteHistoryEntryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHistoryEntryExecute(r)
}

/*
DeleteHistoryEntry Delete a call, fax, SMS or voicemail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiDeleteHistoryEntryRequest
*/
func (a *HistoryApiService) DeleteHistoryEntry(ctx context.Context, entryId string) ApiDeleteHistoryEntryRequest {
	return ApiDeleteHistoryEntryRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
func (a *HistoryApiService) DeleteHistoryEntryExecute(r ApiDeleteHistoryEntryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.DeleteHistoryEntry")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetHistoryRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	connectionIds *[]string
	types *[]string
	directions *[]string
	offset *int32
	limit *int32
	archived *bool
	starred *[]string
	from *string
	to *string
	phonenumber *string
}

// List of extensions
func (r ApiGetHistoryRequest) ConnectionIds(connectionIds []string) ApiGetHistoryRequest {
	r.connectionIds = &connectionIds
	return r
}

// Filter by type
func (r ApiGetHistoryRequest) Types(types []string) ApiGetHistoryRequest {
	r.types = &types
	return r
}

// Filter for incoming/outgoing/missed
func (r ApiGetHistoryRequest) Directions(directions []string) ApiGetHistoryRequest {
	r.directions = &directions
	return r
}

// The offset used for pagination
func (r ApiGetHistoryRequest) Offset(offset int32) ApiGetHistoryRequest {
	r.offset = &offset
	return r
}

// Limit result rows
func (r ApiGetHistoryRequest) Limit(limit int32) ApiGetHistoryRequest {
	r.limit = &limit
	return r
}

// Only show archived events
func (r ApiGetHistoryRequest) Archived(archived bool) ApiGetHistoryRequest {
	r.archived = &archived
	return r
}

// Filter for starred/unstarred
func (r ApiGetHistoryRequest) Starred(starred []string) ApiGetHistoryRequest {
	r.starred = &starred
	return r
}

// Filter &#39;from&#39; date time in ISO8601 format
func (r ApiGetHistoryRequest) From(from string) ApiGetHistoryRequest {
	r.from = &from
	return r
}

// Filter &#39;to&#39; date time in ISO8601 format
func (r ApiGetHistoryRequest) To(to string) ApiGetHistoryRequest {
	r.to = &to
	return r
}

// Filter events to or from given number
func (r ApiGetHistoryRequest) Phonenumber(phonenumber string) ApiGetHistoryRequest {
	r.phonenumber = &phonenumber
	return r
}

func (r ApiGetHistoryRequest) Execute() (*HistoryResponse, *http.Response, error) {
	return r.ApiService.GetHistoryExecute(r)
}

/*
GetHistory List all calls, faxes, SMS and voicemails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoryRequest
*/
func (a *HistoryApiService) GetHistory(ctx context.Context) ApiGetHistoryRequest {
	return ApiGetHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistoryResponse
func (a *HistoryApiService) GetHistoryExecute(r ApiGetHistoryRequest) (*HistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.GetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectionIds != nil {
		t := *r.connectionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("connectionIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("connectionIds", parameterToString(t, "multi"))
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("types", parameterToString(t, "multi"))
		}
	}
	if r.directions != nil {
		t := *r.directions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("directions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("directions", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.starred != nil {
		t := *r.starred
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("starred", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("starred", parameterToString(t, "multi"))
		}
	}
	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	if r.phonenumber != nil {
		localVarQueryParams.Add("phonenumber", parameterToString(*r.phonenumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoryByIdRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
}

func (r ApiGetHistoryByIdRequest) Execute() (*HistoryEntryResponse, *http.Response, error) {
	return r.ApiService.GetHistoryByIdExecute(r)
}

/*
GetHistoryById Get a specific call, fax, SMS or voicemail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiGetHistoryByIdRequest
*/
func (a *HistoryApiService) GetHistoryById(ctx context.Context, entryId string) ApiGetHistoryByIdRequest {
	return ApiGetHistoryByIdRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return HistoryEntryResponse
func (a *HistoryApiService) GetHistoryByIdExecute(r ApiGetHistoryByIdRequest) (*HistoryEntryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryEntryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.GetHistoryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoryCSVRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	connectionIds *[]string
	types *[]string
	directions *[]string
	offset *int32
	limit *int32
	archived *bool
	starred *[]string
	from *string
	to *string
}

// List of extensions
func (r ApiGetHistoryCSVRequest) ConnectionIds(connectionIds []string) ApiGetHistoryCSVRequest {
	r.connectionIds = &connectionIds
	return r
}

// Filter by type
func (r ApiGetHistoryCSVRequest) Types(types []string) ApiGetHistoryCSVRequest {
	r.types = &types
	return r
}

// Filter for incoming/outgoing/missed
func (r ApiGetHistoryCSVRequest) Directions(directions []string) ApiGetHistoryCSVRequest {
	r.directions = &directions
	return r
}

// The offset used for pagination
func (r ApiGetHistoryCSVRequest) Offset(offset int32) ApiGetHistoryCSVRequest {
	r.offset = &offset
	return r
}

// Limit result rows
func (r ApiGetHistoryCSVRequest) Limit(limit int32) ApiGetHistoryCSVRequest {
	r.limit = &limit
	return r
}

// Only show archived events
func (r ApiGetHistoryCSVRequest) Archived(archived bool) ApiGetHistoryCSVRequest {
	r.archived = &archived
	return r
}

// Filter for starred/unstarred
func (r ApiGetHistoryCSVRequest) Starred(starred []string) ApiGetHistoryCSVRequest {
	r.starred = &starred
	return r
}

// Filter &#39;from&#39; date time in ISO8601 format
func (r ApiGetHistoryCSVRequest) From(from string) ApiGetHistoryCSVRequest {
	r.from = &from
	return r
}

// Filter &#39;to&#39; date time in ISO8601 format
func (r ApiGetHistoryCSVRequest) To(to string) ApiGetHistoryCSVRequest {
	r.to = &to
	return r
}

func (r ApiGetHistoryCSVRequest) Execute() (*HistoryResponse, *http.Response, error) {
	return r.ApiService.GetHistoryCSVExecute(r)
}

/*
GetHistoryCSV List all calls, faxes, SMS and voicemails as csv

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoryCSVRequest
*/
func (a *HistoryApiService) GetHistoryCSV(ctx context.Context) ApiGetHistoryCSVRequest {
	return ApiGetHistoryCSVRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistoryResponse
func (a *HistoryApiService) GetHistoryCSVExecute(r ApiGetHistoryCSVRequest) (*HistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.GetHistoryCSV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectionIds != nil {
		t := *r.connectionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("connectionIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("connectionIds", parameterToString(t, "multi"))
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("types", parameterToString(t, "multi"))
		}
	}
	if r.directions != nil {
		t := *r.directions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("directions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("directions", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.starred != nil {
		t := *r.starred
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("starred", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("starred", parameterToString(t, "multi"))
		}
	}
	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetArchiveRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
	body *SetHistoryEntryArchiveRequest
}

func (r ApiSetArchiveRequest) Body(body SetHistoryEntryArchiveRequest) ApiSetArchiveRequest {
	r.body = &body
	return r
}

func (r ApiSetArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetArchiveExecute(r)
}

/*
SetArchive Archive a specific entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiSetArchiveRequest

Deprecated
*/
func (a *HistoryApiService) SetArchive(ctx context.Context, entryId string) ApiSetArchiveRequest {
	return ApiSetArchiveRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
// Deprecated
func (a *HistoryApiService) SetArchiveExecute(r ApiSetArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.SetArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetHistoryEntryNoteRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
	body *SetHistoryEntryNoteRequest
}

func (r ApiSetHistoryEntryNoteRequest) Body(body SetHistoryEntryNoteRequest) ApiSetHistoryEntryNoteRequest {
	r.body = &body
	return r
}

func (r ApiSetHistoryEntryNoteRequest) Execute() (*HistoryEntryResponse, *http.Response, error) {
	return r.ApiService.SetHistoryEntryNoteExecute(r)
}

/*
SetHistoryEntryNote Get a specific call, fax, SMS or voicemail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiSetHistoryEntryNoteRequest

Deprecated
*/
func (a *HistoryApiService) SetHistoryEntryNote(ctx context.Context, entryId string) ApiSetHistoryEntryNoteRequest {
	return ApiSetHistoryEntryNoteRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return HistoryEntryResponse
// Deprecated
func (a *HistoryApiService) SetHistoryEntryNoteExecute(r ApiSetHistoryEntryNoteRequest) (*HistoryEntryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryEntryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.SetHistoryEntryNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}/note"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetReadPropertyRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
	body *SetHistoryEntryReadRequest
}

func (r ApiSetReadPropertyRequest) Body(body SetHistoryEntryReadRequest) ApiSetReadPropertyRequest {
	r.body = &body
	return r
}

func (r ApiSetReadPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetReadPropertyExecute(r)
}

/*
SetReadProperty Mark an specific entry as read or unread

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiSetReadPropertyRequest

Deprecated
*/
func (a *HistoryApiService) SetReadProperty(ctx context.Context, entryId string) ApiSetReadPropertyRequest {
	return ApiSetReadPropertyRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
// Deprecated
func (a *HistoryApiService) SetReadPropertyExecute(r ApiSetReadPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.SetReadProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}/read"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryEntriesRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	body *[]UpdateHistoryEntriesRequest
}

// A list of events which should be updated. Must be less than 150
func (r ApiUpdateHistoryEntriesRequest) Body(body []UpdateHistoryEntriesRequest) ApiUpdateHistoryEntriesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateHistoryEntriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryEntriesExecute(r)
}

/*
UpdateHistoryEntries Update multiple calls, faxes, SMS or voicemails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateHistoryEntriesRequest
*/
func (a *HistoryApiService) UpdateHistoryEntries(ctx context.Context) ApiUpdateHistoryEntriesRequest {
	return ApiUpdateHistoryEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *HistoryApiService) UpdateHistoryEntriesExecute(r ApiUpdateHistoryEntriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.UpdateHistoryEntries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryEntryRequest struct {
	ctx context.Context
	ApiService *HistoryApiService
	entryId string
	body *UpdateHistoryEntryRequest
}

func (r ApiUpdateHistoryEntryRequest) Body(body UpdateHistoryEntryRequest) ApiUpdateHistoryEntryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateHistoryEntryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryEntryExecute(r)
}

/*
UpdateHistoryEntry Update a specific call, fax, SMS or voicemail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId The unique call, fax, sms or voicemail identifier
 @return ApiUpdateHistoryEntryRequest
*/
func (a *HistoryApiService) UpdateHistoryEntry(ctx context.Context, entryId string) ApiUpdateHistoryEntryRequest {
	return ApiUpdateHistoryEntryRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
func (a *HistoryApiService) UpdateHistoryEntryExecute(r ApiUpdateHistoryEntryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoryApiService.UpdateHistoryEntry")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/{entryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
